<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Voice Agent Debugger</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <script src="{{ url_for('static', path='/syncscroll.js') }}"></script>
    <link rel="stylesheet" href="{{ url_for('static', path='/style.css') }}">
</head>
<body>
    <div class="main-container">
        <div class="sidebar">
            <button id="startButton" class="mic-button">Start Voice Agent</button>
            <div id="status" class="status">Microphone: Not active</div>
            <div class="audio-controls">
                <div class="device-select">
                    <label for="inputDevice">Input Device:</label>
                    <select id="inputDevice"></select>
                </div>
            </div>

            <div class="controls">
                <label class="toggle">
                    <input type="checkbox" id="showLogs">
                    <span class="toggle-label">Show Logs</span>
                </label>
                <label class="toggle">
                    <input type="checkbox" id="darkMode" checked>
                    <span class="toggle-label">Dark Mode</span>
                </label>
            </div>
            
        </div>
        <div class="columns-container">
            <div id="conversation" class="timeline column">
                <h2>Conversation</h2>
                <div id="conversationMessages" class="syncscroll" name="timeline"></div>
                
                <div class="footer-prompt-editor">
                    <h3>Agent Prompt</h3>
                    <textarea id="promptText" rows="8" class="prompt-textarea">{{ instructions }}</textarea>
                    <div class="prompt-controls">
                        <button id="updatePromptButton" class="update-button">Update Prompt</button>
                        <div id="promptUpdateStatus" class="update-status"></div>
                    </div>
                </div>

            </div>
            <div id="logs" class="timeline column">
                <h2>Logs</h2>
                <div id="logMessages" class="syncscroll" name="timeline"></div>
            </div>
        </div>

    </div>


    <script>
    // Initialize WebSocket connection
    const socket = new WebSocket('ws://localhost:5000/ws'); // Adjust URL to match your FastAPI server

    const startButton = document.getElementById('startButton');
    const conversationMessages = document.getElementById('conversationMessages');
    const logMessages = document.getElementById('logMessages');
    const statusDiv = document.getElementById('status');
    const showLogsToggle = document.getElementById('showLogs');
    const logsColumn = document.getElementById('logs');
    const inputSelect = document.getElementById('inputDevice');
    let isActive = false;
    let currentGroup = null;
    let lastMessageTimestamp = null;
    let messageCounter = 0;
    const messageHeights = new Map(); // Store heights by counter
    const messageOrder = []; // Keep track of message order

    // logic for stream audio data to server
    let mediaRecorder = null;
    let audioStream = null;

    // Populate audio devices (inputSelect)
    async function loadAudioDevices() {
        try {
            // Request permission to access audio devices
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

            // Get the list of devices
            const devices = await navigator.mediaDevices.enumerateDevices();

            // Stop the temporary stream
            stream.getTracks().forEach(track => track.stop());

            // Clear existing options
            inputSelect.innerHTML = '';

            // Add input devices
            const inputDevices = devices.filter(device => device.kind === 'audioinput');
            inputDevices.forEach(device => {
                const option = document.createElement('option');
                option.value = device.deviceId;
                option.text = device.label || `Microphone ${inputSelect.length + 1}`;
                inputSelect.appendChild(option);
            });

            console.log(`Found ${inputDevices.length} input devices`);
        } catch (err) {
            console.error('Error loading audio devices:', err);
            statusDiv.textContent = 'Error: Could not access audio devices';
        }
    }

    // Load devices initially and when devices change
    navigator.mediaDevices.addEventListener('devicechange', loadAudioDevices);
    loadAudioDevices();

    // Handle WebSocket open
    socket.onopen = () => {
        console.log('Connected to server');
    };

    // Handle WebSocket messages
    socket.onmessage = (event) => {
        const message = JSON.parse(event.data);
        console.log(message)
        const eventType = message.type;
        console.log(eventType)

        if (eventType === 'ConversationText') {
            console.log('On ConversationText')
            const data = message;
            const timestamp = data.timestamp || new Date().toISOString();
            const currentCounter = messageCounter++;
            messageOrder.push({ id: currentCounter, timestamp: timestamp, type: 'conversation' });

            const messageDiv = document.createElement('div');
            messageDiv.className = `timeline-item message ${data.role}`;
            messageDiv.textContent = `${data.role}: ${data.content}`;
            messageDiv.dataset.messageId = currentCounter;

            insertTimelineItem(messageDiv, timestamp, conversationMessages);

            requestAnimationFrame(() => {
                const actualHeight = messageDiv.offsetHeight;
                messageHeights.set(currentCounter, actualHeight);

                const logSpacer = createSpacer(actualHeight);
                logSpacer.dataset.messageId = currentCounter;
                insertTimelineItem(logSpacer, timestamp, logMessages);

                if (!showLogsToggle.checked) {
                    logSpacer.style.display = 'none';
                    logSpacer.style.height = '0';
                }

                syncscroll.reset();
                scrollToBottom();
            });
        } else if (eventType === 'log_message') {
            const data = message;
            const currentCounter = messageCounter++;
            messageOrder.push({ id: currentCounter, timestamp: data.timestamp, type: 'log' });

            const logDiv = document.createElement('div');
            logDiv.className = 'timeline-item log-message';
            logDiv.setAttribute('data-original-text', data.message);
            logDiv.innerHTML = convertAnsiToHtml(data.message);
            logDiv.dataset.messageId = currentCounter;

            insertTimelineItem(logDiv, data.timestamp, logMessages);

            requestAnimationFrame(() => {
                const actualHeight = logDiv.offsetHeight;
                messageHeights.set(currentCounter, actualHeight);

                const conversationSpacer = createSpacer(actualHeight);
                conversationSpacer.dataset.messageId = currentCounter;
                insertTimelineItem(conversationSpacer, data.timestamp, conversationMessages);

                if (!showLogsToggle.checked) {
                    conversationSpacer.style.display = 'none';
                    conversationSpacer.style.height = '0';
                }

                syncscroll.reset();
                scrollToBottom();
            });
        } else if (eventType === 'error') {
            console.error('Server error:', message.message);
            alert('An error occurred: ' + message.message);
        }
    };

    // Handle WebSocket close
    socket.onclose = () => {
        console.log('Disconnected from server');
        isActive = false;
        startButton.textContent = 'Start Voice Agent';
        statusDiv.textContent = 'Microphone: Not active';
        // stop audio stream
        stopAudioStreaming(); // @NEW
    };

    // Handle WebSocket errors
    socket.onerror = (error) => {
        console.error('WebSocket error:', error);
        alert('A connection error occurred. Please check the console for details.');
    };

    // Send selected devices to server when starting
    startButton.addEventListener('click', async () => {
        if (!isActive) {
            const hasPermission = await requestMicrophonePermission();
            if (!hasPermission) {
                alert('Microphone permission is required for the voice agent to work.');
                return;
            }

            socket.send(JSON.stringify({
                type: 'start',
                // event: 'start_voice_agent',
                // data: {
                //     inputDeviceId: inputSelect.value
                // }
            }));
            startButton.textContent = 'Stop Voice Agent';
            statusDiv.textContent = 'Microphone: Active';
            isActive = true;

            // @NEW start streaming audio
            // startAudioStreaming(inputSelect.value);
        } else {
            socket.send(JSON.stringify({
                type: 'stop',
                // event: 'stop_voice_agent',
                // data: {}
            }));
            startButton.textContent = 'Start Voice Agent';
            statusDiv.textContent = 'Microphone: Not active';
            isActive = false;

            // @NEW stop streaming audio
            // stopAudioStreaming();
        }
    });



    // @NEW 
    async function startAudioStreaming(deviceId) {
        try {
            // Get audio stream from the selected device
            audioStream = await navigator.mediaDevices.getUserMedia({
                audio: {
                    deviceId: deviceId ? { exact: deviceId } : undefined,
                    sampleRate: 16000,
                    channelCount: 1,
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true
                }
            });

             // Use MediaRecorder API for efficient audio capture
             mediaRecorder = new MediaRecorder(audioStream, {
                mimeType: 'audio/webm;codecs=opus',
                audioBitsPerSecond: 16000
            });

            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0 && socket.readyState === WebSocket.OPEN && isActive) {
                    // Convert blob to arrayBuffer and send the binary data
                    event.data.arrayBuffer().then(buffer => {
                        // Create a new buffer that includes the header byte + audio data
                        const audioBuffer = new Uint8Array(buffer);
                        const combinedBuffer = new Uint8Array(1 + audioBuffer.length);
                        
                        // Set the first byte as the header (1 = audio data marker)
                        combinedBuffer[0] = 1;
                        
                        // Copy the audio data after the header
                        combinedBuffer.set(audioBuffer, 1);
                        
                        // Send the combined buffer in a single message
                        socket.send(combinedBuffer);
                    });
                }
            };
            // Start recording and send data every 100ms
            mediaRecorder.start(100);
            console.log('Started audio streaming with MediaRecorder');
        } catch (err) {
            console.error('Error starting audio stream:', err);
            statusDiv.textContent = 'Error: Could not access microphone';
        }
    }

     // @NEW Function to stop streaming audio
     function stopAudioStreaming() {
        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
            mediaRecorder.stop();
            mediaRecorder = null;
        }
        
        if (audioStream) {
            audioStream.getTracks().forEach(track => track.stop());
            audioStream = null;
        }
        console.log('Stopped audio streaming');
    }


    async function requestMicrophonePermission() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            statusDiv.textContent = 'Microphone: Permission granted';
            stream.getTracks().forEach(track => track.stop()); // Stop the stream as we don't need it yet
            return true;
        } catch (err) {
            console.error('Error accessing microphone:', err);
            statusDiv.textContent = 'Microphone: Permission denied';
            return false;
        }
    }

    function createSpacer(height) {
        const spacer = document.createElement('div');
        spacer.className = 'timeline-spacer';
        spacer.style.height = `${height}px`;
        return spacer;
    }

    function scrollToBottom() {
        requestAnimationFrame(() => {
            conversationMessages.scrollTop = conversationMessages.scrollHeight;
            logMessages.scrollTop = logMessages.scrollHeight;
        });
    }
    function insertTimelineItem(element, timestamp, container) {
        const time = new Date(timestamp);

        // Find the correct position to insert the new element
        const items = container.children;
        let insertPosition = container.childNodes.length;

        for (let i = 0; i < items.length; i++) {
            const itemTime = new Date(items[i].dataset.timestamp);
            if (time < itemTime) {
                insertPosition = i;
                break;
            }
        }

        element.dataset.timestamp = timestamp;

        if (insertPosition === container.childNodes.length) {
            container.appendChild(element);
        } else {
            container.insertBefore(element, items[insertPosition]);
        }
    }

    function convertAnsiToHtml(text) {
        const ansiToHtml = {
            // Dark mode colors
            dark: {
                '[38;5;231m': 'color: #fff;',     // WHITE
                '[38;5;116m': 'color: #87d7d7;',  // BLUE
                '[38;5;114m': 'color: #87d787;',  // GREEN
                '[38;5;183m': 'color: #d7afff;',  // VIOLET
                '[38;5;186m': 'color: #d7d787;',  // YELLOW
            },
            // Light mode colors (darker variants)
            light: {
                '[38;5;231m': 'color: #000;',     // BLACK
                '[38;5;116m': 'color: #0086b3;',  // BLUE
                '[38;5;114m': 'color: #008744;',  // GREEN
                '[38;5;183m': 'color: #8b3d90;',  // VIOLET
                '[38;5;186m': 'color: #b36d00;',  // YELLOW
            },
            // Reset is the same for both
            '[0m': ''
        };

        // First remove all reset codes from the text
        let html = text.replace(/\[0m/g, '');
        const isDarkMode = document.body.classList.contains('dark-mode');
        const colorSet = isDarkMode ? ansiToHtml.dark : ansiToHtml.light;

        for (const [ansi, style] of Object.entries(colorSet)) {
            const parts = html.split(ansi);
            if (parts.length > 1) {
                html = parts.map((part, i) => {
                    if (i === 0) return part;
                    return `<span style="${style}">${part}</span>`;
                }).join('');
            }
        }

        return html;
    }

    showLogsToggle.addEventListener('change', () => {
        logsColumn.style.display = showLogsToggle.checked ? 'flex' : 'none';

        if (showLogsToggle.checked) {
            // Process messages in chronological order
            messageOrder.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

            // First reset all spacers
            const allSpacers = document.querySelectorAll('.timeline-spacer');
            allSpacers.forEach(spacer => {
                spacer.style.display = 'block';
                const messageId = spacer.dataset.messageId;
                const height = messageHeights.get(parseInt(messageId));
                if (height) {
                    spacer.style.height = `${height}px`;
                }
            });

            messageOrder.forEach(message => {
                const height = messageHeights.get(message.id);
                if (height) {
                    const logItem = logMessages.querySelector(`[data-message-id="${message.id}"]`);
                    const conversationItem = conversationMessages.querySelector(`[data-message-id="${message.id}"]`);

                    if (logItem && conversationItem) {
                        if (message.type === 'log') {
                            logItem.style.display = 'block';
                            if (conversationItem.classList.contains('timeline-spacer')) {
                                conversationItem.style.display = 'block';
                                conversationItem.style.height = `${height}px`;
                            }
                        } else {
                            conversationItem.style.display = 'block';
                            if (logItem.classList.contains('timeline-spacer')) {
                                logItem.style.display = 'block';
                                logItem.style.height = `${height}px`;
                            }
                        }
                    }
                }
            });

            requestAnimationFrame(() => {
                syncscroll.reset();
            });
        } else {
            const allSpacers = document.querySelectorAll('.timeline-spacer');
            allSpacers.forEach(spacer => {
                spacer.style.display = 'none';
                spacer.style.height = '0';
            });
        }
    });

    // Initialize logs visibility
    logsColumn.style.display = showLogsToggle.checked ? 'flex' : 'none';

    const darkModeToggle = document.getElementById('darkMode');

    // Initialize theme
    document.body.classList.toggle('dark-mode', darkModeToggle.checked);

    // Theme toggle handler
    darkModeToggle.addEventListener('change', () => {
        document.body.classList.toggle('dark-mode', darkModeToggle.checked);

        // Save preference
        localStorage.setItem('darkMode', darkModeToggle.checked);

        // Reprocess all log messages with new colors
        const logMessages = document.querySelectorAll('.timeline-item.log-message');
        logMessages.forEach(logMessage => {
            const originalText = logMessage.getAttribute('data-original-text');
            if (originalText) {
                logMessage.innerHTML = convertAnsiToHtml(originalText);
            }
        });
    });

    // Load saved preference
    document.addEventListener('DOMContentLoaded', () => {
        const savedDarkMode = localStorage.getItem('darkMode');
        if (savedDarkMode !== null) {
            const isDarkMode = savedDarkMode === 'true';
            darkModeToggle.checked = isDarkMode;
            document.body.classList.toggle('dark-mode', isDarkMode);
        }
    });

    function toggleCustomer(card) {
        const wasCollapsed = card.classList.contains('collapsed');

        // First collapse all cards
        document.querySelectorAll('.customer-card').forEach(otherCard => {
            otherCard.classList.add('collapsed');
        });

        // Then expand the clicked card if it was collapsed
        if (wasCollapsed) {
            card.classList.remove('collapsed');
        }
    }

    // Initialize all cards as collapsed
    document.addEventListener('DOMContentLoaded', () => {
        const cards = document.querySelectorAll('.customer-card');
        cards.forEach(card => {
            card.classList.add('collapsed');
            // Add click handler to entire card
            card.addEventListener('click', () => toggleCustomer(card));
        });
    });


    // Prompt update functionality
    document.getElementById('updatePromptButton').addEventListener('click', async function() {
            const promptText = document.getElementById('promptText').value;
            const statusElement = document.getElementById('promptUpdateStatus');
            
            statusElement.textContent = "Updating...";
            
            try {
                const response = await fetch('/api/demo/update-prompt', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ prompt: promptText }),
                });
                
                if (response.ok) {
                    statusElement.textContent = "Prompt updated successfully!";
                    statusElement.style.color = "green";
                    setTimeout(() => {
                        statusElement.textContent = "";
                    }, 3000);
                } else {
                    const error = await response.json();
                    statusElement.textContent = `Error: ${error.detail || 'Failed to update prompt'}`;
                    statusElement.style.color = "red";
                }
            } catch (error) {
                statusElement.textContent = `Error: ${error.message}`;
                statusElement.style.color = "red";
            }
        });

</script>
</body>
</html>